# This file is part of
# PyADF - A Scripting Framework for Multiscale Quantum Chemistry.
# Copyright (C) 2006-2022 by Christoph R. Jacob, Tobias Bergmann,
# S. Maya Beyhan, Julia Br√ºggemann, Rosa E. Bulo, Maria Chekmeneva,
# Thomas Dresselhaus, Kevin Focke, Andre S. P. Gomes, Andreas Goetz, 
# Michal Handzlik, Karin Kiewisch, Moritz Klammler, Lars Ridder, 
# Jetze Sikkema, Lucas Visscher, Johannes Vornweg and Mario Wolter.
#
#    PyADF is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    PyADF is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with PyADF.  If not, see <https://www.gnu.org/licenses/>.
"""
Classes for writing grids and grid functions to file.
"""

import kf
import os
import subprocess
import numpy
import functools

from ..Errors import PyAdfError


class GridWriter:

    @classmethod
    def write_tape10(cls, grid, filename='TAPE10'):
        """
        Write a TAPE10 file containing the gridpoints.
        """
        from .Grids import adfgrid

        f = kf.kffile(filename)

        lblock = 128
        if grid.npoints % lblock == 0:
            dummypoints = 0
        else:
            dummypoints = lblock - (grid.npoints % lblock)
        npoints_total = grid.npoints + dummypoints
        nblock = npoints_total // lblock

        f.writeints('General', 'nspin', 1)

        f.writeints("Points", "nblock", nblock)
        f.writeints("Points", "lblock", lblock)
        f.writeints("Points", "nmax", npoints_total)
        f.writeints("Points", "Equivalent Blocks", 1)

        f.writeints("Points", "Length of Blocks", [lblock] * nblock)

        data = numpy.zeros((npoints_total, 4))
        data[:grid.npoints, :3] = grid.get_coordinates(bohr=True)
        data[:grid.npoints, 3] = grid.weights

        outdata = numpy.zeros((nblock, lblock * 4))

        for iblock in range(nblock):
            ipoint = lblock * iblock

            # get one block of points
            block = data[ipoint:ipoint + lblock, :]
            # points have to be written in Fortran ordering !
            block = block.flatten(order='F')

            outdata[iblock, :] = block

        outdata = outdata.flatten()

        f.writereals('Points', 'Data', outdata)
        f.close()

        if isinstance(grid, adfgrid):
            if kf.kffile.env is not None:
                env = kf.kffile.env
            else:
                env = os.environ

            cpkfCmd = [os.path.join(env.setdefault('AMSBIN', ''), 'cpkf'),
                       grid.get_grid_tape10_filename(), filename, 'Num Int Params']

            DEVNULL = open(os.devnull, 'wb')
            subprocess.Popen(cpkfCmd, stdout=DEVNULL, stderr=DEVNULL, env=env)

    @classmethod
    def write_xyzw(cls, grid, filename, bohr=True, endmarker=False, add_comment=True):
        """
        Write the grid in XYZW format.

        File will be in the following format:

        On the first line is the number of grid points,
        If add_comment is True: on the second line is a comment (title of the file).

        On each of the following lines, there are four reals numbers: X, Y, Z, W,
        where X,Y,Z are the coordinates of the grid point (in Angstrom),
        W are the integration weights for the grid.

        If endmarker is True, a negative integer serving as end-of-file
        marker, is written in the last line
        """
        f = open(filename, 'w', encoding='utf-8')
        f.write(f'{grid.npoints:d} \n')

        if add_comment:
            if bohr:
                f.write('# XYZW file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('# XYZW file generated by PyADF (Coordinates in Angstrom)\n')

        for c, w in zip(grid.coorditer(bohr=bohr), grid.weightiter()):
            f.write(f"{c[0]:26.18e}  {c[1]:26.18e}  {c[2]:26.18e}  {w:26.18e}\n")

        if endmarker:
            f.write('  -42\n')

        f.close()


# the following functions are decorators for the methods of GridFunctionWriter


def ensure_1d(func):
    """
    Decorator to ensure that write_* class method is applied to 1D grid function.
    """

    @functools.wraps(func)
    def _wrapper(cls, gf, *args, **kwargs):
        from .GridFunctions import GridFunction1D
        if not isinstance(gf, GridFunction1D):
            raise PyAdfError(f"{func.__name__} is only applicable for 1D grid functions")
        func(cls, gf, *args, **kwargs)

    return _wrapper


def ensure_cubegrid(func):
    """
    Decorator to ensure that write_* class method is applied for a cube grid function.
    """

    @functools.wraps(func)
    def _wrapper(cls, gf, *args, **kwargs):
        from .Grids import cubegrid
        if not isinstance(gf.grid, cubegrid):
            raise PyAdfError(f'{func.__name__} only possible if cubegrid has been used')
        func(cls, gf, *args, **kwargs)

    return _wrapper


class GridFunctionWriter:

    @classmethod
    def write_t10(cls, gf, filename, sec, var):
        f = kf.kffile(filename)

        lblock = 128
        if gf.grid.npoints % lblock == 0:
            dummypoints = 0
        else:
            dummypoints = lblock - (gf.grid.npoints % lblock)
        npoints_total = gf.grid.npoints + dummypoints
        nblock = npoints_total // lblock

        if len(gf.values.shape) == 1:
            nval = 1
            data = numpy.zeros((npoints_total,))
            data[:gf.grid.npoints] = gf.values
        elif len(gf.values.shape) == 2:
            nval = gf.values.shape[1]
            data = numpy.zeros((npoints_total, nval))
            data[:gf.grid.npoints, :] = gf.values
        else:
            raise PyAdfError("write_t10 only applicable for 1D and 2D gridfunctions")

        outdata = numpy.zeros((nblock, lblock*nval))

        for iblock in range(nblock):
            ipoint = lblock * iblock

            # get one block of points
            block = data[ipoint:ipoint + lblock]
            # points have to be written in Fortran ordering !
            block = block.flatten(order='F')

            outdata[iblock, :] = block

        outdata = outdata.flatten()

        f.writereals(sec, var, outdata)
        f.close()

    @classmethod
    @ensure_1d
    def write_xyzwv(cls, gf, filename, bohr=True, endmarker=False, add_comment=True):
        """
        Obtain an XYZWV file of a 1D grid function.

        File will be in the following format:

        On the first line is the number of grid points.
        The second line is empty or a comment (title of the file).

        On each of the following lines, there are five reals numbers: X, Y, Z, W, V,
        where X,Y,Z are the coordinates of the grid point (in Angstrom),
        W are the integration weights for the grid, and V is the value
        (i.e., density) in this grid point.

        @param gf: The grid function to write.
        @type gf: L{1DGridFunction}

        @param filename: The filename of the file to be written.
        @type  filename: str

        @param bohr: Whether to write the coordinates in bohr (default is Angstrom)
        @type bohr: bool

        @param endmarker: If True, a negative integer serving as end-of-file marker, is written in the last line
        @type endmarker: bool

        @param add_comment: If True, a comment is added on the second line (title of the file).
        @type add_comment: bool
        """
        f = open(filename, 'w', encoding='utf-8')
        f.write(f'{gf.grid.npoints:d} \n')

        if add_comment:
            if bohr:
                f.write('# XYZW file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('# XYZW file generated by PyADF (Coordinates in Angstrom)\n')

        for c, w, v in zip(gf.grid.coorditer(bohr=bohr), gf.grid.weightiter(), gf.valueiter()):
            f.write(f"{c[0]:26.18e}  {c[1]:26.18e}  {c[2]:26.18e}     {w:26.18e}     {v:26.18e} \n")

        if endmarker:
            f.write('  -42\n')
        f.close()

    @classmethod
    @ensure_1d
    def write_xyzv(cls, gf, filename, bohr=False, endmarker=False, add_comment=True):
        """
        Obtain a XYZV file of a 1D grid function.

        File will be in the following format:

        On the first line is the number of grid points.
        The second line is empty or a comment (title of the file).

        On each of the following lines, there are four reals numbers: X, Y, Z, V,
        where X,Y,Z are the coordinates of the grid point (in Angstrom)
        and V is the value (i.e., density) in this grid point.

        @param gf: The grid function to write.
        @type gf: L{1DGridFunction}

        @param filename: The filename of the file to be written.
        @type  filename: str

        @param bohr: Whether to write the coordinates in bohr (default is Angstrom)
        @type bohr: bool

        @param endmarker: If True, a negative integer serving as end-of-file marker, is written in the last line
        @type endmarker: bool

        @param add_comment: If True, a comment is added on the second line (title of the file).
        @type add_comment: bool
        """
        f = open(filename, 'w', encoding='utf-8')
        f.write(f'{gf.grid.npoints:d} \n')

        if add_comment:
            if bohr:
                f.write('XYZV file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('XYZV file generated by PyADF (Coordinates in Angstrom)\n')

        for c, v in zip(gf.grid.coorditer(bohr=bohr), gf.valueiter()):
            f.write(f"{c[0]:16.8e}  {c[1]:16.8e}  {c[2]:16.8e}     {v:16.8e} \n")

        if endmarker:
            f.write('  -42\n')
        f.close()

    @classmethod
    @ensure_1d
    @ensure_cubegrid
    def write_cube(cls, gf, filename):
        """
        Obtain a Gaussian-type cube file of a 1D grid function.

        @param gf: The grid function to write.
        @type gf: L{1DGridFunction}

        @param filename: The filename of the cube file to be written.
        @type  filename: str
        """
        values = gf.get_values()

        f = open(filename, 'w', encoding='utf-8')
        # first two lines are title
        f.write('Cube file generated by PyADF \n')
        f.write(str(gf.prop) + '\n')
        # cube file grid specification
        f.write(gf.grid.get_cube_header())

        for ix in range(gf.grid.shape[0]):
            for iy in range(gf.grid.shape[1]):
                for iz in range(gf.grid.shape[2]):
                    f.write(f'{values[ix, iy, iz]:13.5e}')
                    if iz % 6 == 5:
                        f.write('\n')
                f.write('\n')
        f.close()

    @classmethod
    @ensure_1d
    @ensure_cubegrid
    def write_xsf(cls, gf, filename):
        """
        Obtain a XSF file of the associated density.

        @attention: Density values in the file are in atomic units!

        @param gf: The grid function to write.
        @type gf: L{1DGridFunction}

        @param filename: The filename of the xsf file to be written.
        @type  filename: str
        """
        f = open(filename, 'w', encoding='utf-8')
        f.write(gf.grid.get_xsf_header())

        # now write the values (in the correct order)
        values = gf.get_values()
        for iz in range(gf.grid.shape[2]):
            for iy in range(gf.grid.shape[1]):
                for ix in range(gf.grid.shape[0]):
                    f.write(f'{values[ix, iy, iz]:26.18e} \n')

        f.write(gf.grid.get_xsf_footer())

        f.close()
