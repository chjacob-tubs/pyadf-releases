# -*- coding: utf-8 -*-

# This file is part of
# PyADF - A Scripting Framework for Multiscale Quantum Chemistry.
# Copyright (C) 2006-2021 by Christoph R. Jacob, Tobias Bergmann,
# S. Maya Beyhan, Julia Br√ºggemann, Rosa E. Bulo, Thomas Dresselhaus,
# Andre S. P. Gomes, Andreas Goetz, Michal Handzlik, Karin Kiewisch,
# Moritz Klammler, Lars Ridder, Jetze Sikkema, Lucas Visscher, and
# Mario Wolter.
#
#    PyADF is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    PyADF is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with PyADF.  If not, see <http://www.gnu.org/licenses/>.
"""
Classes for writing grids and grid functions to file.
"""

import kf
import numpy

from ..Errors import PyAdfError


class GridWriter(object):

    @classmethod
    def write_tape10(cls, grid, filename='TAPE10'):
        """
        Write a TAPE10 file containing the gridpoints.
        """
        f = kf.kffile(filename)

        lblock = 128
        if grid.npoints % lblock == 0:
            dummypoints = 0
        else:
            dummypoints = lblock - (grid.npoints % lblock)
        npoints_total = grid.npoints + dummypoints
        nblock = npoints_total / lblock

        f.writeints('General', 'nspin', 1)

        f.writeints("Points", "nblock", nblock)
        f.writeints("Points", "lblock", lblock)
        f.writeints("Points", "nmax", npoints_total)
        f.writeints("Points", "Equivalent Blocks", 1)

        f.writeints("Points", "Length of Blocks", [lblock] * nblock)

        data = numpy.zeros((npoints_total, 4))
        data[:grid.npoints, :3] = grid.get_coordinates(bohr=True)
        data[:grid.npoints, 3] = grid.get_weights()

        outdata = numpy.zeros((nblock, lblock * 4))

        for iblock in range(nblock):
            ipoint = lblock * iblock

            # get one block of points
            block = data[ipoint:ipoint + lblock, :]
            # points have to be written in Fortran ordering !
            block = block.flatten(True)

            outdata[iblock, :] = block

        outdata = outdata.flatten()

        f.writereals('Points', 'Data', outdata)
        f.close()

    @classmethod
    def write_xyzw(cls, grid, filename, bohr=True, endmarker=False, add_comment=True):
        """
        Write the grid in XYZW format.

        File will be in the following format:

        On the first line is the number of grid points,
        If add_comment is True: on the second line is a comment (title of the file).

        On each of the following lines, there are four reals numbers: X, Y, Z, W,
        where X,Y,Z are the coordinates of the grid point (in Angstrom),
        W are the integration weights for the grid.

        If endmarker is True, a negative integer serving as end-of-file
        marker, is written in the last line
        """
        f = open(filename, 'w')
        f.write('%i \n' % grid.npoints)

        if add_comment:
            if bohr:
                f.write('# XYZW file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('# XYZW file generated by PyADF (Coordinates in Angstrom)\n')

        for c, w in zip(grid.coorditer(bohr=bohr), grid.weightiter()):
            f.write("%26.18e  %26.18e  %26.18e  %26.18e\n"
                    % (c[0], c[1], c[2], w))

        if endmarker:
            f.write('  -42\n')

        f.close()


class GridFunctionWriter(object):

    # pylint: disable=E0213
    def ensure_1D(func):
        """
        Decorator to ensure that write_* class method is applied to 1D grid function.
        """

        def _wrapper(cls, gf, *args, **kwargs):
            from GridFunctions import GridFunction1D
            if not isinstance(gf, GridFunction1D):
                raise PyAdfError("%s is only applicable for 1D grid functions" % func.__name__)
            # pylint: disable=E1102
            func(cls, gf, *args, **kwargs)

        return _wrapper

    # pylint: disable=E0213
    def ensure_cubegrid(func):
        """
        Decorator to ensure that write_* class method is applied for a cube grid function.
        """

        def _wrapper(cls, gf, *args, **kwargs):
            from Grids import cubegrid
            if not isinstance(gf.grid, cubegrid):
                raise PyAdfError('%s only possible if cubegrid has been used' % func.__name__)
            # pylint: disable=E1102
            func(cls, gf, *args, **kwargs)

        return _wrapper

    @classmethod
    @ensure_1D
    def write_xyzwv(cls, gf, filename, bohr=True, endmarker=False, add_comment=True):
        """
        Obtain an XYZWV file of a 1D grid function.

        File will be in the following format:

        On the first line is the number of grid points,
        If add_comment is True: on the second line is a comment (title of the file).

        On each of the following lines, there are five reals numbers: X, Y, Z, W, V,
        where X,Y,Z are the coordinates of the grid point (in Angstrom),
        W are the integration weights for the grid, and V is the value
        (i.e., density) in this grid point.

        If endmarker is True: a negative integer serving as end-of-file marker,
        is written in the last line

        @param filename: The filename of the file to be written.
        @type  filename: str
        """
        f = open(filename, 'w')
        f.write('%i \n' % gf.grid.npoints)

        if add_comment:
            if bohr:
                f.write('# XYZW file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('# XYZW file generated by PyADF (Coordinates in Angstrom)\n')

        for c, w, v in zip(gf.grid.coorditer(bohr=bohr), gf.grid.weightiter(), gf.valueiter()):
            f.write("%26.18e  %26.18e  %26.18e     %26.18e     %26.18e \n"
                    % (c[0], c[1], c[2], w, v))

        if endmarker:
            f.write('  -42\n')
        f.close()

    @classmethod
    @ensure_1D
    def write_xyzv(cls, gf, filename, bohr=False, endmarker=False, add_comment=True):
        """
        Obtain a XYZV file of a 1D grid function.

        File will be in the following format:

        On the first line is the number of grid points,
        If add_comment is True: on the second line is a comment (title of the file).

        On each of the following lines, there are four reals numbers: X, Y, Z, V,
        where X,Y,Z are the coordinates of the grid point (in Angstrom)
        and V is the value (i.e., density) in this grid point.

        If endmarker is True: a negative integer serving as end-of-file marker,
        is written in the last line

        @param filename: The filename of the file to be written.
        @type  filename: str
        """
        f = open(filename, 'w')
        f.write('%i \n' % gf.grid.npoints)

        if add_comment:
            if bohr:
                f.write('XYZV file generated by PyADF (Coordinates in Bohr)\n')
            else:
                f.write('XYZV file generated by PyADF (Coordinates in Angstrom)\n')

        for c, v in zip(gf.grid.coorditer(bohr=bohr), gf.valueiter()):
            f.write("%16.8e  %16.8e  %16.8e     %16.8e \n" % (c[0], c[1], c[2], v))

        if endmarker:
            f.write('  -42\n')
        f.close()

    @classmethod
    @ensure_1D
    @ensure_cubegrid
    def write_cube(cls, gf, filename):
        """
        Obtain a Gaussian-type cube file of a 1D grid function.

        @param filename: The filename of the cube file to be written.
        @type  filename: str
        """
        values = gf.get_values()

        f = open(filename, 'w')
        # first two lines are title
        f.write('Cube file generated by PyADF \n')
        f.write(str(gf.prop) + '\n')
        # cube file grid specification
        f.write(gf.grid.get_cube_header())

        for ix in range(gf.grid.shape[0]):
            for iy in range(gf.grid.shape[1]):
                for iz in range(gf.grid.shape[2]):
                    f.write('%13.5e' % values[ix, iy, iz])
                    if (iz % 6 == 5):
                        f.write('\n')
                f.write('\n')
        f.close()

    @classmethod
    @ensure_1D
    @ensure_cubegrid
    def write_xsf(cls, gf, filename):
        """
        Obtain a XSF file of the associated density.

        @attention: Density values in the file are in atomic units!

        @param filename: The filename of the xsf file to be written.
        @type  filename: str
        """
        f = open(filename, 'w')
        f.write(gf.grid.get_xsf_header())

        # now write the values (in the correct order)
        values = gf.get_values()
        for iz in range(gf.grid.shape[2]):
            for iy in range(gf.grid.shape[1]):
                for ix in range(gf.grid.shape[0]):
                    f.write('%26.18e \n' % values[ix, iy, iz])

        f.write(gf.grid.get_xsf_footer())

        f.close()

    del ensure_1D
    del ensure_cubegrid
